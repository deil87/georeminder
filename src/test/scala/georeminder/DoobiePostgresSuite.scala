/*
 * This Scala Testsuite was generated by the Gradle 'init' task.
 */
package georeminder

import cats.effect.{Blocker, IO}
import cats._
import cats.data.NonEmptyList
import cats.effect._
import cats.implicits._
import doobie.free.connection.ConnectionIO
import org.scalatest.funsuite.AnyFunSuite
import org.junit.runner.RunWith
import org.scalatestplus.junit.JUnitRunner
import doobie.util.ExecutionContexts
import doobie.util.transactor.Transactor
import doobie._
import doobie.implicits._
import doobie.util.transactor.Transactor.Aux



@RunWith(classOf[JUnitRunner])
class DoobiePostgresSuite extends AnyFunSuite {

  // We need a ContextShift[IO] before we can construct a Transactor[IO]. The passed ExecutionContext
  // is where nonblocking operations will be executed. For testing here we're using a synchronous EC.
  implicit val cs: ContextShift[IO] = IO.contextShift(ExecutionContexts.synchronous)

  // A transactor that gets connections from java.sql.DriverManager and executes blocking operations
  // on an our synchronous EC. See the chapter on connection handling for more info.
  val xa: Aux[IO, Unit] = Transactor.fromDriverManager[IO](
    "org.postgresql.Driver",     // driver classname
    "jdbc:postgresql:world",     // connect URL (driver-specific)
    "postgres",                  // user
    "admin",                          // password
    Blocker.liftExecutionContext(ExecutionContexts.synchronous) // just for testing
  )

  val y = xa.yolo
  import y._

  test("someLibraryMethod is always true") {


    val program1 = 42.pure[ConnectionIO]
    val io = program1.transact(xa)
    val result = io.unsafeRunSync()
    assert(result == 42)
  }

  test("select 42") {


    val program2: doobie.ConnectionIO[Int] = sql"select 42".query[Int].unique
    val io = program2.transact(xa)
    val result = io.unsafeRunSync()
    assert(result == 42)
  }

  test("Compose two commands") {

    val program3: ConnectionIO[(Int, Double)] =
      for {
        a <- sql"select 42".query[Int].unique
        b <- sql"select random()".query[Double].unique
      } yield (a, b)

    val result: (Int, Double) = program3.transact(xa).unsafeRunSync()
    assert(result._1 == 42)
    assert(result._2.isInstanceOf[Double])
  }

  test("select list of countries") {

      sql"select name from country"
        .query[String]    // Query0[String]
        .to[List]         // ConnectionIO[List[String]]
        .transact(xa)     // IO[List[String]]
        .unsafeRunSync    // List[String]
        .take(5)          // List[String]
        .foreach(println)

    sql"select name from country"
      .query[String]    // Query0[String]
      .stream
      .take(5)
      .compile.toList   // ConnectionIO[List[String]]
      .transact(xa)     // IO[List[String]]
      .unsafeRunSync    // List[String]
      .foreach(println)
  }

  case class Country(code: String, name: String, pop: Int, gnp: Option[Double])

  test("IN clause") {

    def populationIn(range: Range, codes: NonEmptyList[String]) = {
      val q = fr"""
    select code, name, population, gnp
    from country
    where population > ${range.min}
    and   population < ${range.max}
    and   """ ++ Fragments.in(fr"code", codes) // code IN (...)
      q.query[Country]
    }

    populationIn(100000000 to 300000000, NonEmptyList.of("USA", "BRA", "PAK", "GBR")).quick.unsafeRunSync
  }
}
